## DESCRIPTION
##   Apply the Central Limit Theorem
## ENDDESCRIPTION

## KEYWORDS('Probability', 'Central Limit Theorem')
## Tagged by nhamblet

## DBsubject('Probability')
## DBchapter('Theory')
## DBsection('The Central Limit Theorem')
## Date('')
## Author('')
## Institution('Rochester')
## TitleText1('')
## EditionText1('')
## AuthorText1('')
## Section1('')
## Problem1('')

DOCUMENT();        # This should be the first executable line in the problem.

loadMacros(
"PG.pl",
"PGML.pl",
"MathObjects.pl",
"PGbasicmacros.pl",
"PGchoicemacros.pl",
"PGanswermacros.pl",
"PGgraphmacros.pl",
"PGnumericalmacros.pl",
"PGstatisticsmacros.pl"
);

TEXT(beginproblem());
$showPartialCorrectAnswers = 1;

package my::Function::numeric;
our @ISA = ('Parser::Function::numeric');

sub Q {
   shift; my $x = shift;
   return main::normal_prob($x, 'infty', mean=>0, deviation=>1);
}

sub Phi {
   shift; my $x = shift;
   return main::normal_prob('-infty', $x, mean=>0, deviation=>1);
}

sub erf {
   shift; my $x = shift;
   $phi = main::normal_prob('-infty', $x*sqrt(2), mean=>0, deviation=>1);
   $a = 2*$phi-1;
   return $a;
}

package main;

Context("Numeric");
Context()->functions->add(
erf =>{class=>"my::Function::numeric", nocomplex=>1},
Q =>{class=>"my::Function::numeric", nocomplex=>1}, 
Phi =>{class=>"my::Function::numeric", nocomplex=>1}
);
Context()->flags->set(tolerance=>0.001);

Context()->texStrings;


Context()->variables->are(
      i => ['Real', limits=>[1,100], resolution=>1],
      j => ['Real', limits=>[1,100], resolution=>1],
      k => ['Real', limits=>[1,100], resolution=>1],
      n => ['Real', limits=>[1,100], resolution=>1],
    );


BEGIN_PGML

## Quicksort ##
---
The *quicksort* algorithm works as follows: (For more information see http://en.wikipedia.org/wiki/Quicksort)
---
*function* quicksort(S)  
- Pick an element [`v`] from [`S`] at random  
- Split [`S`] into three pieces:  
   - [`S_L`], elements less than [`v`]  
   - [`S_v`], elements equal to [`v`]  
   - [`S_R`], elements greater than [`v`]   
- Return [`\mbox{quicksort}(S_L) \circ S_v \circ \mbox{quicksort}(S_R)`]    ([`\circ`] is concatenation)

---

In this problem, we will analyze the expected running time of this algorithm.

First, notice that all the work is done in splitting the various arrays: the original array 
and the many subarrays generated by recursive invocations. Each split operation involves
_comparing_ all elements of the array to the _split element_ [`v`]. Therefore

[$BCENTER]*
[`` \mbox{total running time of quicksort} \ \ = \ \ \sum_{i,j} X_{ij} ``]
[$ECENTER]*

where [`X_{ij}`] is the number of times [`S[i]`] and [`S[j]`] are compared; such comparisons occur
only when one of them is the split element.

It will be convenient to let [`S_{(i)}`] denote the [`i`]th largest element in the 
array; and to instead define [`X_{ij}`] as the number of times [`S_{(i)}`] and [`S_{(j)}`] get
compared. The formula for the running time remains the same.

The second useful observation is that [`X_{ij}`] is never more than 1: if [`S_{(i)}`] and
[`S_{(j)}`] are compared at some point, it means one of them is the split element; thus they
will end up in separate arrays and never again be compared. Let [`p_{ij}`] be the probability
that [`S_{(i)}`] and [`S_{(j)}`] are compared at some stage. Thus [`\mathbb{E}(X_{ij}) = p_{ij}`].

1. Suppose [`j > i`]. Consider the elements [`S_{(i)}, S_{(i+1)}, \ldots, S_{(j-1)}, S_{(j)}`]
in the original array. At some point, this group of elements will be split: they will no 
longer remain within a single subarray. This happens when the split element [`v`] ends up 
being one of these [`j-i+1`] elements.  The pivot first splitting this subarray will land with equal probability on one of the [`j-i+1`] elements: in how many cases will the this result in [`i`] and [`j`] being compared?  [_____]{"2"}.  With this in mind, [`p_{ij} = `][______]{2/(j-i+1)}.  
2. For [`j=i`] we are talking about a subsequence of length one, how many subsequences of length one are there in [`S_{(1)}, S_{(2)}, \ldots, S_{(n-1)}, S_{(n)}`]? [_______]{n}
3. How about for [`j=i+1`]? these are sequences of length 2, how many sequences of length two are there? [_______]{n-1}?  How about sequences of length 3? [`j=i+2`]?  [_______]{n-2}.
4. Let [`l_k = \sum_{i=1}^{n-k+1} {X_{i,i+k-1}}`] be a random variable giving the number of comparisons between elements that are exactly [`k-1`] units apart.  
5. *Roughly* what is [`\mathbb{E}(l_k)`] in terms of [`n`] and [`k`]?  [______]{2*n/k}  Note: for [`k = j - i + 1`], [`p_{ij}`] can be written in terms of [`k`]: [`p_{ij} = 2/k`].  Assume for any [`k`], the number of sequences of length [`k`] is roughly [`n`].  
6. Using the harmonic series approximation [`\sum_{i=1}^{n}{1/i} \sim \ln(n)`] and your results above, *roughly* what is the expected runtime of quicksort?  [_______]{n*2*log(n)}

This is [`O(n \log n)`], right?
END_PGML

ENDDOCUMENT();       # This should be the last executable line in the problem.